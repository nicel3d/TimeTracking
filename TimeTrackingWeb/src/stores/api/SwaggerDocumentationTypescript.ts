/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.5.0 (NJsonSchema v9.13.37.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class WSApi {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : "";
  }

  users_ErrorBaseRegistred(errorBase: ErrorBase | null): Promise<void> {
    let url_ = this.baseUrl + "/api/Users/ErrorBaseRegistred";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(errorBase);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUsers_ErrorBaseRegistred(_response);
    });
  }

  protected processUsers_ErrorBaseRegistred(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  users_Authenticate(authenticateRequest: AuthenticateRequest | null): Promise<SecurityTokenUser | null> {
    let url_ = this.baseUrl + "/api/Users/Authenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(authenticateRequest);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUsers_Authenticate(_response);
    });
  }

  protected processUsers_Authenticate(response: Response): Promise<SecurityTokenUser | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? SecurityTokenUser.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SecurityTokenUser | null>(<any>null);
  }

  users_GetAll(): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/Users";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUsers_GetAll(_response);
    });
  }

  protected processUsers_GetAll(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(<any>null);
  }

  activityStaff_GetList(request: TableSortingWithFilterRequest | null): Promise<ActivityStaffListResponse | null> {
    let url_ = this.baseUrl + "/api/ActivityStaff/GetList";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processActivityStaff_GetList(_response);
    });
  }

  protected processActivityStaff_GetList(response: Response): Promise<ActivityStaffListResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ActivityStaffListResponse.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ActivityStaffListResponse | null>(<any>null);
  }

  activityStaff_Get(id: number): Promise<ActivityStaff | null> {
    let url_ = this.baseUrl + "/api/ActivityStaff/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processActivityStaff_Get(_response);
    });
  }

  protected processActivityStaff_Get(response: Response): Promise<ActivityStaff | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ActivityStaff.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ActivityStaff | null>(<any>null);
  }

  activityStaff_Put(id: number, activityStaff: ActivityStaff | null): Promise<void> {
    let url_ = this.baseUrl + "/api/ActivityStaff/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(activityStaff);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processActivityStaff_Put(_response);
    });
  }

  protected processActivityStaff_Put(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  activityStaff_Delete(id: number): Promise<void> {
    let url_ = this.baseUrl + "/api/ActivityStaff/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processActivityStaff_Delete(_response);
    });
  }

  protected processActivityStaff_Delete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  activityStaff_Post(activityStaff: ActivityStaff | null): Promise<ActivityStaff | null> {
    let url_ = this.baseUrl + "/api/ActivityStaff/Post";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(activityStaff);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processActivityStaff_Post(_response);
    });
  }

  protected processActivityStaff_Post(response: Response): Promise<ActivityStaff | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ActivityStaff.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ActivityStaff | null>(<any>null);
  }

  applications_GetListWithRange(request: TableSortingWithFilterRequest | null): Promise<ApplicationsRangeListResponse | null> {
    let url_ = this.baseUrl + "/api/Applications/GetListWithRange";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApplications_GetListWithRange(_response);
    });
  }

  protected processApplications_GetListWithRange(response: Response): Promise<ApplicationsRangeListResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ApplicationsRangeListResponse.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ApplicationsRangeListResponse | null>(<any>null);
  }

  applications_GetList(request: TableSortingRequest | null): Promise<ApplicationsListResponse | null> {
    let url_ = this.baseUrl + "/api/Applications/GetList";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApplications_GetList(_response);
    });
  }

  protected processApplications_GetList(response: Response): Promise<ApplicationsListResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ApplicationsListResponse.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ApplicationsListResponse | null>(<any>null);
  }

  applications_GetListFull(request: TableSortingByGroupIdRequest | null): Promise<Applications[] | null> {
    let url_ = this.baseUrl + "/api/Applications/GetListFull";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApplications_GetListFull(_response);
    });
  }

  protected processApplications_GetListFull(response: Response): Promise<Applications[] | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Applications.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Applications[] | null>(<any>null);
  }

  applications_ImportXLSXGetListWithoutFilter(request: TableSortingRequest | null): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/Applications/ImportXLSXGetListWithoutFilter";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApplications_ImportXLSXGetListWithoutFilter(_response);
    });
  }

  protected processApplications_ImportXLSXGetListWithoutFilter(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(<any>null);
  }

  applications_ImportCSVGetListWithoutFilter(request: TableSortingRequest | null): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/Applications/ImportCSVGetListWithoutFilter";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApplications_ImportCSVGetListWithoutFilter(_response);
    });
  }

  protected processApplications_ImportCSVGetListWithoutFilter(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(<any>null);
  }

  applications_Get(id: number): Promise<Applications | null> {
    let url_ = this.baseUrl + "/api/Applications/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApplications_Get(_response);
    });
  }

  protected processApplications_Get(response: Response): Promise<Applications | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? Applications.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Applications | null>(<any>null);
  }

  applications_PutState(id: number, stateEnum: StateEnum): Promise<void> {
    let url_ = this.baseUrl + "/api/Applications/{id}?";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (stateEnum === undefined || stateEnum === null)
      throw new Error("The parameter 'stateEnum' must be defined and cannot be null.");
    else
      url_ += "stateEnum=" + encodeURIComponent("" + stateEnum) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "PUT",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApplications_PutState(_response);
    });
  }

  protected processApplications_PutState(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  applications_Delete(id: number): Promise<void> {
    let url_ = this.baseUrl + "/api/Applications/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApplications_Delete(_response);
    });
  }

  protected processApplications_Delete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  applications_Post(applications: Applications | null): Promise<Applications | null> {
    let url_ = this.baseUrl + "/api/Applications/Post";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(applications);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processApplications_Post(_response);
    });
  }

  protected processApplications_Post(response: Response): Promise<Applications | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? Applications.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Applications | null>(<any>null);
  }

  staff_GetList(request: TableSortingByGroupIdRequest | null): Promise<StaffListResponse | null> {
    let url_ = this.baseUrl + "/api/Staff/GetList";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processStaff_GetList(_response);
    });
  }

  protected processStaff_GetList(response: Response): Promise<StaffListResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? StaffListResponse.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<StaffListResponse | null>(<any>null);
  }

  staff_GetListFull(request: TableSortingByGroupIdRequest | null): Promise<Staff[] | null> {
    let url_ = this.baseUrl + "/api/Staff/GetListFull";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processStaff_GetListFull(_response);
    });
  }

  protected processStaff_GetListFull(response: Response): Promise<Staff[] | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Staff.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Staff[] | null>(<any>null);
  }

  staff_GetListOnlyByGropupId(groupId: number): Promise<Staff[] | null> {
    let url_ = this.baseUrl + "/api/Staff/GetListOnlyByGropupId";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(groupId);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processStaff_GetListOnlyByGropupId(_response);
    });
  }

  protected processStaff_GetListOnlyByGropupId(response: Response): Promise<Staff[] | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Staff.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Staff[] | null>(<any>null);
  }

  staff_ImportXLSXGetListWithoutFilter(request: TableSortingByGroupIdRequest | null): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/Staff/ImportXLSXGetListWithoutFilter";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processStaff_ImportXLSXGetListWithoutFilter(_response);
    });
  }

  protected processStaff_ImportXLSXGetListWithoutFilter(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(<any>null);
  }

  staff_ImportCSVGetListWithoutFilter(request: TableSortingByGroupIdRequest | null): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/Staff/ImportCSVGetListWithoutFilter";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processStaff_ImportCSVGetListWithoutFilter(_response);
    });
  }

  protected processStaff_ImportCSVGetListWithoutFilter(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(<any>null);
  }

  staff_Get(id: number): Promise<Staff | null> {
    let url_ = this.baseUrl + "/api/Staff/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processStaff_Get(_response);
    });
  }

  protected processStaff_Get(response: Response): Promise<Staff | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? Staff.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Staff | null>(<any>null);
  }

  staff_Delete(id: number): Promise<void> {
    let url_ = this.baseUrl + "/api/Staff/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processStaff_Delete(_response);
    });
  }

  protected processStaff_Delete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  staff_Post(staff: Staff | null): Promise<Staff | null> {
    let url_ = this.baseUrl + "/api/Staff/Post";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(staff);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processStaff_Post(_response);
    });
  }

  protected processStaff_Post(response: Response): Promise<Staff | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? Staff.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Staff | null>(<any>null);
  }

  group_GetList(request: TableSortingRequest | null): Promise<GroupListResponse | null> {
    let url_ = this.baseUrl + "/api/Group/GetList";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGroup_GetList(_response);
    });
  }

  protected processGroup_GetList(response: Response): Promise<GroupListResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? GroupListResponse.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<GroupListResponse | null>(<any>null);
  }

  group_GetListWithCountUsers(request: TableSortingRequest | null): Promise<GroupsListWithCountUsersResponse | null> {
    let url_ = this.baseUrl + "/api/Group/GetListWithCountUsers";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGroup_GetListWithCountUsers(_response);
    });
  }

  protected processGroup_GetListWithCountUsers(response: Response): Promise<GroupsListWithCountUsersResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? GroupsListWithCountUsersResponse.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<GroupsListWithCountUsersResponse | null>(<any>null);
  }

  group_ImportXLSXGetListWithoutFilter(request: TableSortingRequest | null): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/Group/ImportXLSXGetListWithoutFilter";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGroup_ImportXLSXGetListWithoutFilter(_response);
    });
  }

  protected processGroup_ImportXLSXGetListWithoutFilter(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(<any>null);
  }

  group_ImportCSVGetListWithoutFilter(request: TableSortingRequest | null): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/Group/ImportCSVGetListWithoutFilter";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGroup_ImportCSVGetListWithoutFilter(_response);
    });
  }

  protected processGroup_ImportCSVGetListWithoutFilter(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(<any>null);
  }

  group_Get(id: number): Promise<Groups | null> {
    let url_ = this.baseUrl + "/api/Group/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGroup_Get(_response);
    });
  }

  protected processGroup_Get(response: Response): Promise<Groups | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? Groups.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Groups | null>(<any>null);
  }

  group_Put(id: number, group: Groups | null): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/Group/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(group);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGroup_Put(_response);
    });
  }

  protected processGroup_Put(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(<any>null);
  }

  group_Delete(id: number): Promise<void> {
    let url_ = this.baseUrl + "/api/Group/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGroup_Delete(_response);
    });
  }

  protected processGroup_Delete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  group_Post(group: Groups | null): Promise<Groups | null> {
    let url_ = this.baseUrl + "/api/Group/Post";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(group);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGroup_Post(_response);
    });
  }

  protected processGroup_Post(response: Response): Promise<Groups | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? Groups.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Groups | null>(<any>null);
  }

  group_PostStaffToGroup(staffToGroup: StaffToGroup | null): Promise<StaffToGroup | null> {
    let url_ = this.baseUrl + "/api/Group/PostStaffToGroup";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(staffToGroup);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGroup_PostStaffToGroup(_response);
    });
  }

  protected processGroup_PostStaffToGroup(response: Response): Promise<StaffToGroup | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? StaffToGroup.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<StaffToGroup | null>(<any>null);
  }

  group_DeleteStaffToGroup(staffToGroup: StaffToGroup | null): Promise<void> {
    let url_ = this.baseUrl + "/api/Group/DeleteStaffToGroup";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(staffToGroup);

    let options_ = <RequestInit>{
      body: content_,
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGroup_DeleteStaffToGroup(_response);
    });
  }

  protected processGroup_DeleteStaffToGroup(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  treatmentApplications_GetList(request: ApplicationGroupFilterRequest | null): Promise<VMApplicationGroupListResponse | null> {
    let url_ = this.baseUrl + "/api/TreatmentApplications/GetList";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTreatmentApplications_GetList(_response);
    });
  }

  protected processTreatmentApplications_GetList(response: Response): Promise<VMApplicationGroupListResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? VMApplicationGroupListResponse.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<VMApplicationGroupListResponse | null>(<any>null);
  }

  treatmentApplications_ImportXLSXGetListWithoutFilter(request: ApplicationGroupFilterRequest | null): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/TreatmentApplications/ImportXLSXGetListWithoutFilter";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTreatmentApplications_ImportXLSXGetListWithoutFilter(_response);
    });
  }

  protected processTreatmentApplications_ImportXLSXGetListWithoutFilter(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(<any>null);
  }

  treatmentApplications_ImportCSVGetListWithoutFilter(request: ApplicationGroupFilterRequest | null): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/TreatmentApplications/ImportCSVGetListWithoutFilter";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTreatmentApplications_ImportCSVGetListWithoutFilter(_response);
    });
  }

  protected processTreatmentApplications_ImportCSVGetListWithoutFilter(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(<any>null);
  }

  treatmentApplications_Get(id: number): Promise<ApplicationToGroup | null> {
    let url_ = this.baseUrl + "/api/TreatmentApplications/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTreatmentApplications_Get(_response);
    });
  }

  protected processTreatmentApplications_Get(response: Response): Promise<ApplicationToGroup | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ApplicationToGroup.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ApplicationToGroup | null>(<any>null);
  }

  treatmentApplications_Put(id: number, request: ApplicationToGroup | null): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/TreatmentApplications/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTreatmentApplications_Put(_response);
    });
  }

  protected processTreatmentApplications_Put(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(<any>null);
  }

  treatmentApplications_Delete(id: number): Promise<void> {
    let url_ = this.baseUrl + "/api/TreatmentApplications/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTreatmentApplications_Delete(_response);
    });
  }

  protected processTreatmentApplications_Delete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  treatmentApplications_Post(request: ApplicationToGroup | null): Promise<ApplicationToGroup | null> {
    let url_ = this.baseUrl + "/api/TreatmentApplications/Post";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTreatmentApplications_Post(_response);
    });
  }

  protected processTreatmentApplications_Post(response: Response): Promise<ApplicationToGroup | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? ApplicationToGroup.fromJS(resultData200) : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ApplicationToGroup | null>(<any>null);
  }

  settings_GetList(): Promise<Settings[] | null> {
    let url_ = this.baseUrl + "/api/Settings/GetList";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "POST",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSettings_GetList(_response);
    });
  }

  protected processSettings_GetList(response: Response): Promise<Settings[] | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Settings.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Settings[] | null>(<any>null);
  }

  settings_Post(settings: Settings[] | null): Promise<Settings[] | null> {
    let url_ = this.baseUrl + "/api/Settings/Post";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(settings);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSettings_Post(_response);
    });
  }

  protected processSettings_Post(response: Response): Promise<Settings[] | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Settings.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Settings[] | null>(<any>null);
  }

  values_GetAll(): Promise<string[] | null> {
    let url_ = this.baseUrl + "/api/Values";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processValues_GetAll(_response);
    });
  }

  protected processValues_GetAll(response: Response): Promise<string[] | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(item);
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<string[] | null>(<any>null);
  }

  values_Post(value: string | null): Promise<void> {
    let url_ = this.baseUrl + "/api/Values";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(value);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processValues_Post(_response);
    });
  }

  protected processValues_Post(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  values_Get(id: number): Promise<string | null> {
    let url_ = this.baseUrl + "/api/Values/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processValues_Get(_response);
    });
  }

  protected processValues_Get(response: Response): Promise<string | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<string | null>(<any>null);
  }

  values_Put(id: number, value: string | null): Promise<void> {
    let url_ = this.baseUrl + "/api/Values/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(value);

    let options_ = <RequestInit>{
      body: content_,
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processValues_Put(_response);
    });
  }

  protected processValues_Put(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  values_Delete(id: number): Promise<void> {
    let url_ = this.baseUrl + "/api/Values/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processValues_Delete(_response);
    });
  }

  protected processValues_Delete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class ErrorBase implements IErrorBase {
  errorCode!: number;
  failReason?: string | undefined;
  exceptionType?: string | undefined;

  constructor(data?: IErrorBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.errorCode = data["ErrorCode"];
      this.failReason = data["FailReason"];
      this.exceptionType = data["ExceptionType"];
    }
  }

  static fromJS(data: any): ErrorBase {
    data = typeof data === 'object' ? data : {};
    let result = new ErrorBase();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["ErrorCode"] = this.errorCode;
    data["FailReason"] = this.failReason;
    data["ExceptionType"] = this.exceptionType;
    return data;
  }
}

export interface IErrorBase {
  errorCode: number;
  failReason?: string | undefined;
  exceptionType?: string | undefined;
}

export class SecurityTokenUser implements ISecurityTokenUser {
  token?: string | undefined;
  userFullName?: string | undefined;

  constructor(data?: ISecurityTokenUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.token = data["Token"];
      this.userFullName = data["UserFullName"];
    }
  }

  static fromJS(data: any): SecurityTokenUser {
    data = typeof data === 'object' ? data : {};
    let result = new SecurityTokenUser();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Token"] = this.token;
    data["UserFullName"] = this.userFullName;
    return data;
  }
}

export interface ISecurityTokenUser {
  token?: string | undefined;
  userFullName?: string | undefined;
}

export class AuthenticateRequest implements IAuthenticateRequest {
  email?: string | undefined;
  password?: string | undefined;

  constructor(data?: IAuthenticateRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.email = data["Email"];
      this.password = data["Password"];
    }
  }

  static fromJS(data: any): AuthenticateRequest {
    data = typeof data === 'object' ? data : {};
    let result = new AuthenticateRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Email"] = this.email;
    data["Password"] = this.password;
    return data;
  }
}

export interface IAuthenticateRequest {
  email?: string | undefined;
  password?: string | undefined;
}

export class ListCountResponse implements IListCountResponse {
  total!: number;

  constructor(data?: IListCountResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.total = data["Total"];
    }
  }

  static fromJS(data: any): ListCountResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ListCountResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Total"] = this.total;
    return data;
  }
}

export interface IListCountResponse {
  total: number;
}

export class ActivityStaffListResponse extends ListCountResponse implements IActivityStaffListResponse {
  data?: ActivityStaffThumb[] | undefined;

  constructor(data?: IActivityStaffListResponse) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      if (data["Data"] && data["Data"].constructor === Array) {
        this.data = [] as any;
        for (let item of data["Data"])
          this.data!.push(ActivityStaffThumb.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ActivityStaffListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ActivityStaffListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.data && this.data.constructor === Array) {
      data["Data"] = [];
      for (let item of this.data)
        data["Data"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IActivityStaffListResponse extends IListCountResponse {
  data?: ActivityStaffThumb[] | undefined;
}

export class ActivityStaff implements IActivityStaff {
  id!: number;
  updatedAt!: Date;
  applicationTitle?: string | undefined;
  staffId?: number | undefined;
  imageOrigin?: string | undefined;
  imageThumb?: string | undefined;
  applicationId?: number | undefined;
  application?: Applications | undefined;
  staff?: Staff | undefined;

  constructor(data?: IActivityStaff) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["Id"];
      this.updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
      this.applicationTitle = data["ApplicationTitle"];
      this.staffId = data["StaffId"];
      this.imageOrigin = data["ImageOrigin"];
      this.imageThumb = data["ImageThumb"];
      this.applicationId = data["ApplicationId"];
      this.application = data["Application"] ? Applications.fromJS(data["Application"]) : <any>undefined;
      this.staff = data["Staff"] ? Staff.fromJS(data["Staff"]) : <any>undefined;
    }
  }

  static fromJS(data: any): ActivityStaff {
    data = typeof data === 'object' ? data : {};
    let result = new ActivityStaff();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Id"] = this.id;
    data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    data["ApplicationTitle"] = this.applicationTitle;
    data["StaffId"] = this.staffId;
    data["ImageOrigin"] = this.imageOrigin;
    data["ImageThumb"] = this.imageThumb;
    data["ApplicationId"] = this.applicationId;
    data["Application"] = this.application ? this.application.toJSON() : <any>undefined;
    data["Staff"] = this.staff ? this.staff.toJSON() : <any>undefined;
    return data;
  }
}

export interface IActivityStaff {
  id: number;
  updatedAt: Date;
  applicationTitle?: string | undefined;
  staffId?: number | undefined;
  imageOrigin?: string | undefined;
  imageThumb?: string | undefined;
  applicationId?: number | undefined;
  application?: Applications | undefined;
  staff?: Staff | undefined;
}

export class ActivityStaffThumb extends ActivityStaff implements IActivityStaffThumb {
  imageThumb?: string | undefined;

  constructor(data?: IActivityStaffThumb) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.imageThumb = data["ImageThumb"];
    }
  }

  static fromJS(data: any): ActivityStaffThumb {
    data = typeof data === 'object' ? data : {};
    let result = new ActivityStaffThumb();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["ImageThumb"] = this.imageThumb;
    super.toJSON(data);
    return data;
  }
}

export interface IActivityStaffThumb extends IActivityStaff {
  imageThumb?: string | undefined;
}

export class Applications implements IApplications {
  id!: number;
  caption?: string | undefined;
  updatedAt!: Date;
  state!: StateEnum;
  activityStaff?: ActivityStaff[] | undefined;
  applicationTitles?: ApplicationTitles[] | undefined;
  applicationToGroup?: ApplicationToGroup[] | undefined;

  constructor(data?: IApplications) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["Id"];
      this.caption = data["Caption"];
      this.updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
      this.state = data["State"];
      if (data["ActivityStaff"] && data["ActivityStaff"].constructor === Array) {
        this.activityStaff = [] as any;
        for (let item of data["ActivityStaff"])
          this.activityStaff!.push(ActivityStaff.fromJS(item));
      }
      if (data["ApplicationTitles"] && data["ApplicationTitles"].constructor === Array) {
        this.applicationTitles = [] as any;
        for (let item of data["ApplicationTitles"])
          this.applicationTitles!.push(ApplicationTitles.fromJS(item));
      }
      if (data["ApplicationToGroup"] && data["ApplicationToGroup"].constructor === Array) {
        this.applicationToGroup = [] as any;
        for (let item of data["ApplicationToGroup"])
          this.applicationToGroup!.push(ApplicationToGroup.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Applications {
    data = typeof data === 'object' ? data : {};
    let result = new Applications();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Id"] = this.id;
    data["Caption"] = this.caption;
    data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    data["State"] = this.state;
    if (this.activityStaff && this.activityStaff.constructor === Array) {
      data["ActivityStaff"] = [];
      for (let item of this.activityStaff)
        data["ActivityStaff"].push(item.toJSON());
    }
    if (this.applicationTitles && this.applicationTitles.constructor === Array) {
      data["ApplicationTitles"] = [];
      for (let item of this.applicationTitles)
        data["ApplicationTitles"].push(item.toJSON());
    }
    if (this.applicationToGroup && this.applicationToGroup.constructor === Array) {
      data["ApplicationToGroup"] = [];
      for (let item of this.applicationToGroup)
        data["ApplicationToGroup"].push(item.toJSON());
    }
    return data;
  }
}

export interface IApplications {
  id: number;
  caption?: string | undefined;
  updatedAt: Date;
  state: StateEnum;
  activityStaff?: ActivityStaff[] | undefined;
  applicationTitles?: ApplicationTitles[] | undefined;
  applicationToGroup?: ApplicationToGroup[] | undefined;
}

export enum StateEnum {
  Allowed = 0,
  Forbidden = 1,
  Neutral = 2,
}

export class ApplicationTitles implements IApplicationTitles {
  id?: number | undefined;
  title!: string;
  updatedAt?: Date | undefined;
  applicationId!: number;
  application?: Applications | undefined;
  applicationTitleToGroup?: ApplicationTitleToGroup[] | undefined;

  constructor(data?: IApplicationTitles) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["Id"];
      this.title = data["Title"];
      this.updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
      this.applicationId = data["ApplicationId"];
      this.application = data["Application"] ? Applications.fromJS(data["Application"]) : <any>undefined;
      if (data["ApplicationTitleToGroup"] && data["ApplicationTitleToGroup"].constructor === Array) {
        this.applicationTitleToGroup = [] as any;
        for (let item of data["ApplicationTitleToGroup"])
          this.applicationTitleToGroup!.push(ApplicationTitleToGroup.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ApplicationTitles {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationTitles();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Id"] = this.id;
    data["Title"] = this.title;
    data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    data["ApplicationId"] = this.applicationId;
    data["Application"] = this.application ? this.application.toJSON() : <any>undefined;
    if (this.applicationTitleToGroup && this.applicationTitleToGroup.constructor === Array) {
      data["ApplicationTitleToGroup"] = [];
      for (let item of this.applicationTitleToGroup)
        data["ApplicationTitleToGroup"].push(item.toJSON());
    }
    return data;
  }
}

export interface IApplicationTitles {
  id?: number | undefined;
  title: string;
  updatedAt?: Date | undefined;
  applicationId: number;
  application?: Applications | undefined;
  applicationTitleToGroup?: ApplicationTitleToGroup[] | undefined;
}

export class ApplicationTitleToGroup implements IApplicationTitleToGroup {
  id?: number | undefined;
  applicationTitleId?: number | undefined;
  groupId?: number | undefined;
  updatedAt?: Date | undefined;
  state!: StateEnum;
  applicationTitle?: ApplicationTitles | undefined;
  group?: Groups | undefined;

  constructor(data?: IApplicationTitleToGroup) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["Id"];
      this.applicationTitleId = data["ApplicationTitleId"];
      this.groupId = data["GroupId"];
      this.updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
      this.state = data["State"];
      this.applicationTitle = data["ApplicationTitle"] ? ApplicationTitles.fromJS(data["ApplicationTitle"]) : <any>undefined;
      this.group = data["Group"] ? Groups.fromJS(data["Group"]) : <any>undefined;
    }
  }

  static fromJS(data: any): ApplicationTitleToGroup {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationTitleToGroup();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Id"] = this.id;
    data["ApplicationTitleId"] = this.applicationTitleId;
    data["GroupId"] = this.groupId;
    data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    data["State"] = this.state;
    data["ApplicationTitle"] = this.applicationTitle ? this.applicationTitle.toJSON() : <any>undefined;
    data["Group"] = this.group ? this.group.toJSON() : <any>undefined;
    return data;
  }
}

export interface IApplicationTitleToGroup {
  id?: number | undefined;
  applicationTitleId?: number | undefined;
  groupId?: number | undefined;
  updatedAt?: Date | undefined;
  state: StateEnum;
  applicationTitle?: ApplicationTitles | undefined;
  group?: Groups | undefined;
}

export class Groups implements IGroups {
  id?: number | undefined;
  name!: string;
  status?: boolean | undefined;
  updatedAt?: Date | undefined;
  applicationTitleToGroup?: ApplicationTitleToGroup[] | undefined;
  applicationToGroup?: ApplicationToGroup[] | undefined;
  staffToGroup?: StaffToGroup[] | undefined;

  constructor(data?: IGroups) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["Id"];
      this.name = data["Name"];
      this.status = data["Status"];
      this.updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
      if (data["ApplicationTitleToGroup"] && data["ApplicationTitleToGroup"].constructor === Array) {
        this.applicationTitleToGroup = [] as any;
        for (let item of data["ApplicationTitleToGroup"])
          this.applicationTitleToGroup!.push(ApplicationTitleToGroup.fromJS(item));
      }
      if (data["ApplicationToGroup"] && data["ApplicationToGroup"].constructor === Array) {
        this.applicationToGroup = [] as any;
        for (let item of data["ApplicationToGroup"])
          this.applicationToGroup!.push(ApplicationToGroup.fromJS(item));
      }
      if (data["StaffToGroup"] && data["StaffToGroup"].constructor === Array) {
        this.staffToGroup = [] as any;
        for (let item of data["StaffToGroup"])
          this.staffToGroup!.push(StaffToGroup.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Groups {
    data = typeof data === 'object' ? data : {};
    let result = new Groups();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Id"] = this.id;
    data["Name"] = this.name;
    data["Status"] = this.status;
    data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    if (this.applicationTitleToGroup && this.applicationTitleToGroup.constructor === Array) {
      data["ApplicationTitleToGroup"] = [];
      for (let item of this.applicationTitleToGroup)
        data["ApplicationTitleToGroup"].push(item.toJSON());
    }
    if (this.applicationToGroup && this.applicationToGroup.constructor === Array) {
      data["ApplicationToGroup"] = [];
      for (let item of this.applicationToGroup)
        data["ApplicationToGroup"].push(item.toJSON());
    }
    if (this.staffToGroup && this.staffToGroup.constructor === Array) {
      data["StaffToGroup"] = [];
      for (let item of this.staffToGroup)
        data["StaffToGroup"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGroups {
  id?: number | undefined;
  name: string;
  status?: boolean | undefined;
  updatedAt?: Date | undefined;
  applicationTitleToGroup?: ApplicationTitleToGroup[] | undefined;
  applicationToGroup?: ApplicationToGroup[] | undefined;
  staffToGroup?: StaffToGroup[] | undefined;
}

export class ApplicationToGroup implements IApplicationToGroup {
  id?: number | undefined;
  applicationId!: number;
  groupId!: number;
  updatedAt?: Date | undefined;
  state!: StateEnum;
  application?: Applications | undefined;
  group?: Groups | undefined;

  constructor(data?: IApplicationToGroup) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["Id"];
      this.applicationId = data["ApplicationId"];
      this.groupId = data["GroupId"];
      this.updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
      this.state = data["State"];
      this.application = data["Application"] ? Applications.fromJS(data["Application"]) : <any>undefined;
      this.group = data["Group"] ? Groups.fromJS(data["Group"]) : <any>undefined;
    }
  }

  static fromJS(data: any): ApplicationToGroup {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationToGroup();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Id"] = this.id;
    data["ApplicationId"] = this.applicationId;
    data["GroupId"] = this.groupId;
    data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    data["State"] = this.state;
    data["Application"] = this.application ? this.application.toJSON() : <any>undefined;
    data["Group"] = this.group ? this.group.toJSON() : <any>undefined;
    return data;
  }
}

export interface IApplicationToGroup {
  id?: number | undefined;
  applicationId: number;
  groupId: number;
  updatedAt?: Date | undefined;
  state: StateEnum;
  application?: Applications | undefined;
  group?: Groups | undefined;
}

export class StaffToGroup implements IStaffToGroup {
  staffId!: number;
  groupId!: number;
  group?: Groups | undefined;
  staff?: Staff | undefined;

  constructor(data?: IStaffToGroup) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.staffId = data["StaffId"];
      this.groupId = data["GroupId"];
      this.group = data["Group"] ? Groups.fromJS(data["Group"]) : <any>undefined;
      this.staff = data["Staff"] ? Staff.fromJS(data["Staff"]) : <any>undefined;
    }
  }

  static fromJS(data: any): StaffToGroup {
    data = typeof data === 'object' ? data : {};
    let result = new StaffToGroup();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["StaffId"] = this.staffId;
    data["GroupId"] = this.groupId;
    data["Group"] = this.group ? this.group.toJSON() : <any>undefined;
    data["Staff"] = this.staff ? this.staff.toJSON() : <any>undefined;
    return data;
  }
}

export interface IStaffToGroup {
  staffId: number;
  groupId: number;
  group?: Groups | undefined;
  staff?: Staff | undefined;
}

export class Staff implements IStaff {
  id!: number;
  updatedAt?: Date | undefined;
  status?: boolean | undefined;
  activityFirst?: Date | undefined;
  rangeLastActivityTime?: string | undefined;
  activityLast?: Date | undefined;
  caption?: string | undefined;
  activityStaff?: ActivityStaff[] | undefined;
  staffToGroup?: StaffToGroup[] | undefined;

  constructor(data?: IStaff) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["Id"];
      this.updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
      this.status = data["Status"];
      this.activityFirst = data["ActivityFirst"] ? new Date(data["ActivityFirst"].toString()) : <any>undefined;
      this.rangeLastActivityTime = data["RangeLastActivityTime"];
      this.activityLast = data["ActivityLast"] ? new Date(data["ActivityLast"].toString()) : <any>undefined;
      this.caption = data["Caption"];
      if (data["ActivityStaff"] && data["ActivityStaff"].constructor === Array) {
        this.activityStaff = [] as any;
        for (let item of data["ActivityStaff"])
          this.activityStaff!.push(ActivityStaff.fromJS(item));
      }
      if (data["StaffToGroup"] && data["StaffToGroup"].constructor === Array) {
        this.staffToGroup = [] as any;
        for (let item of data["StaffToGroup"])
          this.staffToGroup!.push(StaffToGroup.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Staff {
    data = typeof data === 'object' ? data : {};
    let result = new Staff();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Id"] = this.id;
    data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    data["Status"] = this.status;
    data["ActivityFirst"] = this.activityFirst ? this.activityFirst.toISOString() : <any>undefined;
    data["RangeLastActivityTime"] = this.rangeLastActivityTime;
    data["ActivityLast"] = this.activityLast ? this.activityLast.toISOString() : <any>undefined;
    data["Caption"] = this.caption;
    if (this.activityStaff && this.activityStaff.constructor === Array) {
      data["ActivityStaff"] = [];
      for (let item of this.activityStaff)
        data["ActivityStaff"].push(item.toJSON());
    }
    if (this.staffToGroup && this.staffToGroup.constructor === Array) {
      data["StaffToGroup"] = [];
      for (let item of this.staffToGroup)
        data["StaffToGroup"].push(item.toJSON());
    }
    return data;
  }
}

export interface IStaff {
  id: number;
  updatedAt?: Date | undefined;
  status?: boolean | undefined;
  activityFirst?: Date | undefined;
  rangeLastActivityTime?: string | undefined;
  activityLast?: Date | undefined;
  caption?: string | undefined;
  activityStaff?: ActivityStaff[] | undefined;
  staffToGroup?: StaffToGroup[] | undefined;
}

export class TableSortingRequest implements ITableSortingRequest {
  sorting?: SortingRequest | undefined;
  search?: string | undefined;
  skip?: number | undefined;
  take?: number | undefined;

  constructor(data?: ITableSortingRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.sorting = data["Sorting"] ? SortingRequest.fromJS(data["Sorting"]) : <any>undefined;
      this.search = data["Search"];
      this.skip = data["Skip"];
      this.take = data["Take"];
    }
  }

  static fromJS(data: any): TableSortingRequest {
    data = typeof data === 'object' ? data : {};
    let result = new TableSortingRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Sorting"] = this.sorting ? this.sorting.toJSON() : <any>undefined;
    data["Search"] = this.search;
    data["Skip"] = this.skip;
    data["Take"] = this.take;
    return data;
  }
}

export interface ITableSortingRequest {
  sorting?: SortingRequest | undefined;
  search?: string | undefined;
  skip?: number | undefined;
  take?: number | undefined;
}

export class TableSortingWithFilterRequest extends TableSortingRequest implements ITableSortingWithFilterRequest {
  filter?: FilterRequest | undefined;

  constructor(data?: ITableSortingWithFilterRequest) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.filter = data["Filter"] ? FilterRequest.fromJS(data["Filter"]) : <any>undefined;
    }
  }

  static fromJS(data: any): TableSortingWithFilterRequest {
    data = typeof data === 'object' ? data : {};
    let result = new TableSortingWithFilterRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface ITableSortingWithFilterRequest extends ITableSortingRequest {
  filter?: FilterRequest | undefined;
}

export class FilterRequest implements IFilterRequest {
  begDate!: Date;
  endDate!: Date;
  begHour!: number;
  endHour!: number;

  constructor(data?: IFilterRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.begDate = data["BegDate"] ? new Date(data["BegDate"].toString()) : <any>undefined;
      this.endDate = data["EndDate"] ? new Date(data["EndDate"].toString()) : <any>undefined;
      this.begHour = data["BegHour"];
      this.endHour = data["EndHour"];
    }
  }

  static fromJS(data: any): FilterRequest {
    data = typeof data === 'object' ? data : {};
    let result = new FilterRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["BegDate"] = this.begDate ? this.begDate.toISOString() : <any>undefined;
    data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    data["BegHour"] = this.begHour;
    data["EndHour"] = this.endHour;
    return data;
  }
}

export interface IFilterRequest {
  begDate: Date;
  endDate: Date;
  begHour: number;
  endHour: number;
}

export class SortingRequest implements ISortingRequest {
  descending?: boolean | undefined;
  sortBy?: string | undefined;

  constructor(data?: ISortingRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.descending = data["Descending"];
      this.sortBy = data["SortBy"];
    }
  }

  static fromJS(data: any): SortingRequest {
    data = typeof data === 'object' ? data : {};
    let result = new SortingRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Descending"] = this.descending;
    data["SortBy"] = this.sortBy;
    return data;
  }
}

export interface ISortingRequest {
  descending?: boolean | undefined;
  sortBy?: string | undefined;
}

export class ApplicationsRangeListResponse extends ListCountResponse implements IApplicationsRangeListResponse {
  data?: ApplicationsRange[] | undefined;

  constructor(data?: IApplicationsRangeListResponse) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      if (data["Data"] && data["Data"].constructor === Array) {
        this.data = [] as any;
        for (let item of data["Data"])
          this.data!.push(ApplicationsRange.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ApplicationsRangeListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationsRangeListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.data && this.data.constructor === Array) {
      data["Data"] = [];
      for (let item of this.data)
        data["Data"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IApplicationsRangeListResponse extends IListCountResponse {
  data?: ApplicationsRange[] | undefined;
}

export class ApplicationsRange extends Applications implements IApplicationsRange {
  userUsed!: number;

  constructor(data?: IApplicationsRange) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.userUsed = data["UserUsed"];
    }
  }

  static fromJS(data: any): ApplicationsRange {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationsRange();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["UserUsed"] = this.userUsed;
    super.toJSON(data);
    return data;
  }
}

export interface IApplicationsRange extends IApplications {
  userUsed: number;
}

export class ApplicationsListResponse extends ListCountResponse implements IApplicationsListResponse {
  data?: Applications[] | undefined;

  constructor(data?: IApplicationsListResponse) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      if (data["Data"] && data["Data"].constructor === Array) {
        this.data = [] as any;
        for (let item of data["Data"])
          this.data!.push(Applications.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ApplicationsListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationsListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.data && this.data.constructor === Array) {
      data["Data"] = [];
      for (let item of this.data)
        data["Data"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IApplicationsListResponse extends IListCountResponse {
  data?: Applications[] | undefined;
}

export class TableSortingByGroupIdRequest extends TableSortingRequest implements ITableSortingByGroupIdRequest {
  groupId?: number | undefined;

  constructor(data?: ITableSortingByGroupIdRequest) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.groupId = data["GroupId"];
    }
  }

  static fromJS(data: any): TableSortingByGroupIdRequest {
    data = typeof data === 'object' ? data : {};
    let result = new TableSortingByGroupIdRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["GroupId"] = this.groupId;
    super.toJSON(data);
    return data;
  }
}

export interface ITableSortingByGroupIdRequest extends ITableSortingRequest {
  groupId?: number | undefined;
}

export class StaffListResponse extends ListCountResponse implements IStaffListResponse {
  data?: Staff[] | undefined;

  constructor(data?: IStaffListResponse) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      if (data["Data"] && data["Data"].constructor === Array) {
        this.data = [] as any;
        for (let item of data["Data"])
          this.data!.push(Staff.fromJS(item));
      }
    }
  }

  static fromJS(data: any): StaffListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new StaffListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.data && this.data.constructor === Array) {
      data["Data"] = [];
      for (let item of this.data)
        data["Data"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IStaffListResponse extends IListCountResponse {
  data?: Staff[] | undefined;
}

export class GroupListResponse extends ListCountResponse implements IGroupListResponse {
  data?: Groups[] | undefined;

  constructor(data?: IGroupListResponse) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      if (data["Data"] && data["Data"].constructor === Array) {
        this.data = [] as any;
        for (let item of data["Data"])
          this.data!.push(Groups.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GroupListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GroupListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.data && this.data.constructor === Array) {
      data["Data"] = [];
      for (let item of this.data)
        data["Data"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IGroupListResponse extends IListCountResponse {
  data?: Groups[] | undefined;
}

export class GroupsListWithCountUsersResponse extends ListCountResponse implements IGroupsListWithCountUsersResponse {
  data?: GroupsWithCountUsers[] | undefined;

  constructor(data?: IGroupsListWithCountUsersResponse) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      if (data["Data"] && data["Data"].constructor === Array) {
        this.data = [] as any;
        for (let item of data["Data"])
          this.data!.push(GroupsWithCountUsers.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GroupsListWithCountUsersResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GroupsListWithCountUsersResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.data && this.data.constructor === Array) {
      data["Data"] = [];
      for (let item of this.data)
        data["Data"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IGroupsListWithCountUsersResponse extends IListCountResponse {
  data?: GroupsWithCountUsers[] | undefined;
}

export class GroupsWithCountUsers extends Groups implements IGroupsWithCountUsers {
  countUsers!: number;

  constructor(data?: IGroupsWithCountUsers) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.countUsers = data["CountUsers"];
    }
  }

  static fromJS(data: any): GroupsWithCountUsers {
    data = typeof data === 'object' ? data : {};
    let result = new GroupsWithCountUsers();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["CountUsers"] = this.countUsers;
    super.toJSON(data);
    return data;
  }
}

export interface IGroupsWithCountUsers extends IGroups {
  countUsers: number;
}

export class VMApplicationGroupListResponse extends ListCountResponse implements IVMApplicationGroupListResponse {
  data?: VMApplicationGroup[] | undefined;

  constructor(data?: IVMApplicationGroupListResponse) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      if (data["Data"] && data["Data"].constructor === Array) {
        this.data = [] as any;
        for (let item of data["Data"])
          this.data!.push(VMApplicationGroup.fromJS(item));
      }
    }
  }

  static fromJS(data: any): VMApplicationGroupListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new VMApplicationGroupListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.data && this.data.constructor === Array) {
      data["Data"] = [];
      for (let item of this.data)
        data["Data"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IVMApplicationGroupListResponse extends IListCountResponse {
  data?: VMApplicationGroup[] | undefined;
}

export class VMApplicationGroup extends ApplicationToGroup implements IVMApplicationGroup {
  applicationTitle?: string | undefined;

  constructor(data?: IVMApplicationGroup) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.applicationTitle = data["ApplicationTitle"];
    }
  }

  static fromJS(data: any): VMApplicationGroup {
    data = typeof data === 'object' ? data : {};
    let result = new VMApplicationGroup();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["ApplicationTitle"] = this.applicationTitle;
    super.toJSON(data);
    return data;
  }
}

export interface IVMApplicationGroup extends IApplicationToGroup {
  applicationTitle?: string | undefined;
}

export class ApplicationGroupFilterRequest extends TableSortingRequest implements IApplicationGroupFilterRequest {
  groupId!: number;

  constructor(data?: IApplicationGroupFilterRequest) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.groupId = data["GroupId"];
    }
  }

  static fromJS(data: any): ApplicationGroupFilterRequest {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationGroupFilterRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["GroupId"] = this.groupId;
    super.toJSON(data);
    return data;
  }
}

export interface IApplicationGroupFilterRequest extends ITableSortingRequest {
  groupId: number;
}

export class Settings implements ISettings {
  id!: number;
  timeBreakFrom?: string | undefined;
  timeBreakTo?: string | undefined;
  timeTheadMiliseconds?: number | undefined;
  timeWorkingFrom?: string | undefined;
  timeWorkingTo?: string | undefined;
  updatedAt?: Date | undefined;
  status?: boolean | undefined;

  constructor(data?: ISettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["Id"];
      this.timeBreakFrom = data["TimeBreakFrom"];
      this.timeBreakTo = data["TimeBreakTo"];
      this.timeTheadMiliseconds = data["TimeTheadMiliseconds"];
      this.timeWorkingFrom = data["TimeWorkingFrom"];
      this.timeWorkingTo = data["TimeWorkingTo"];
      this.updatedAt = data["UpdatedAt"] ? new Date(data["UpdatedAt"].toString()) : <any>undefined;
      this.status = data["Status"];
    }
  }

  static fromJS(data: any): Settings {
    data = typeof data === 'object' ? data : {};
    let result = new Settings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Id"] = this.id;
    data["TimeBreakFrom"] = this.timeBreakFrom;
    data["TimeBreakTo"] = this.timeBreakTo;
    data["TimeTheadMiliseconds"] = this.timeTheadMiliseconds;
    data["TimeWorkingFrom"] = this.timeWorkingFrom;
    data["TimeWorkingTo"] = this.timeWorkingTo;
    data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
    data["Status"] = this.status;
    return data;
  }
}

export interface ISettings {
  id: number;
  timeBreakFrom?: string | undefined;
  timeBreakTo?: string | undefined;
  timeTheadMiliseconds?: number | undefined;
  timeWorkingFrom?: string | undefined;
  timeWorkingTo?: string | undefined;
  updatedAt?: Date | undefined;
  status?: boolean | undefined;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
  if(result !== null && result !== undefined)
    throw result;
  else
    throw new SwaggerException(message, status, response, headers, null);
}
